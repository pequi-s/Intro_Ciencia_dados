# -*- coding: utf-8 -*-
"""Agrupamento_morfologia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11M_AQevCEEcm-Ym1dkIrL8w_qs-kuXdd
"""

import pandas as pd
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

# Carregar o arquivo de dados
arquivo_csv = 'dados_classificados_completos.csv'
try:
    dados = pd.read_csv(arquivo_csv)
    print(f"Arquivo '{arquivo_csv}' carregado com sucesso!")
except FileNotFoundError:
    print(f"Erro: O arquivo '{arquivo_csv}' não foi encontrado.")
    exit()

# Exibir as primeiras linhas dos dados
print("\nPrimeiras linhas do dataset:")
print(dados.head())

# Criar a coluna Trophic.Niche com base em uma combinação de condições
def classificar_nicho(row):
    # Classificação dos nichos tróficos com base no comprimento do bico e massa

    # Frugívoro grande
    if row['Beak.Length_Culmen'] > 20 and row['Mass'] > 100:
        return 'Frugívoro grande'

    # Frugívoro pequeno
    elif 5 <= row['Beak.Length_Culmen'] <= 10 and 25 <= row['Mass'] <= 50:
        return 'Frugívoro pequeno'

    # Insetívoro
    elif 0 <= row['Beak.Length_Culmen'] <= 5 and 0 <= row['Mass'] <= 25:
        return 'Insetívoro'

    # Invertívoro
    elif 10 <= row['Beak.Length_Culmen'] <= 20 and 50 <= row['Mass'] <= 100:
        return 'Invertívoro'

    else:
        return 'Não classificado'

# Aplicar a função na coluna Trophic.Niche
dados['Trophic.Niche'] = dados.apply(classificar_nicho, axis=1)

# Mapeamento das categorias para números (Codificação ordinal)
mapeamento = {
    'Frugívoro grande': 1,
    'Frugívoro pequeno': 2,
    'Invertívoro': 3,
    'Insetívoro': 4,
    'Não classificado': 5
}

# Aplicar o mapeamento na coluna 'Trophic.Niche'
dados['Trophic.Niche'] = dados['Trophic.Niche'].map(mapeamento)

# Exibindo os dados classificados
print("\nDados com classificação de nicho trófico:")
print(dados[['Beak.Length_Culmen', 'Mass', 'Trophic.Niche']])

# Remover colunas desnecessárias
dados.drop(columns=['Vertivore'], errors='ignore', inplace=True)

# Verificar as colunas numéricas
colunas_numericas = dados.select_dtypes(include=['float64', 'int64']).columns

# Extrair os dados numéricos
dados_numericos = dados[colunas_numericas]

# Normalizar os dados numéricos usando o StandardScaler
scaler = StandardScaler()
dados_normalizados = scaler.fit_transform(dados_numericos)

# Realizando o agrupamento (clusterização) com K-means
n_clusters = 3  # Defina o número de clusters (ajuste conforme necessário)
kmeans = KMeans(n_clusters=n_clusters, random_state=42)

# Aplicar K-means apenas nos dados numéricos normalizados
dados['Cluster'] = kmeans.fit_predict(dados_normalizados)

# Exibir os dados com a coluna de clusters
print("\nDados com clusters atribuídos:")
print(dados.head())

# Comparando o Cluster com a coluna de classes já existentes (Trophic.Niche)
if 'Trophic.Niche' in dados.columns:
    # Exibir comparação entre clusters e nichos tróficos
    print("\nComparação entre Cluster e Trophic.Niche:")
    print(pd.crosstab(dados['Cluster'], dados['Trophic.Niche']))

# Exibindo o gráfico de dispersão dos clusters com Beak e Mass por Trophic Niche
plt.figure(figsize=(10, 6))

# Plotar pontos para cada Trophic Niche
for niche in dados['Trophic.Niche'].unique():
    subset = dados[dados['Trophic.Niche'] == niche]
    plt.scatter(subset['Beak.Length_Culmen'], subset['Mass'], label=f'Nicho {niche}', s=60, alpha=0.7)

# Adicionar título e rótulos
plt.title("Dispersão de Beak Length e Mass por Trophic Niche", fontsize=14)
plt.xlabel("Comprimento do Bico (Beak Length)", fontsize=12)
plt.ylabel("Massa (Mass)", fontsize=12)

# Mostrar a legenda
plt.legend(title="Trophic Niche", loc='upper right')

# Exibir gráfico
plt.show()

# Salvar os dados finais em um novo arquivo CSV
dados.to_csv('dados_filtrados_aves_com_clusters.csv', index=False)
print("\nArquivo 'dados_filtrados_aves_com_clusters.csv' salvo com sucesso!")